{
  "name": "postcss",
  "version": "2.2.1",
  "description": "Framework for CSS postprocessors with full source map support",
  "keywords": [
    "css",
    "parser",
    "postproccessor",
    "source map"
  ],
  "author": {
    "name": "Andrey Sitnik",
    "email": "andrey@sitnik.ru"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/postcss/postcss.git"
  },
  "dependencies": {
    "source-map": "~0.1.38",
    "js-base64": "~2.1.5"
  },
  "devDependencies": {
    "gulp-es6-transpiler": "1.0.0",
    "gulp-json-editor": "2.0.2",
    "jshint-stylish": "0.4.0",
    "gulp-jshint": "1.8.4",
    "gonzales-pe": "3.0.0-10",
    "gulp-mocha": "1.0.0",
    "gulp-util": "3.0.0",
    "fs-extra": "0.11.0",
    "gonzales": "1.0.7",
    "request": "2.40.0",
    "rework": "1.0.0",
    "should": "4.0.4",
    "mocha": "1.21.4",
    "cssom": "0.3.0",
    "gulp": "3.8.7",
    "es6-transpiler": "~0.7.14-2"
  },
  "scripts": {
    "test": "gulp"
  },
  "main": "lib/postcss",
  "readme": "# PostCSS [![Build Status](https://travis-ci.org/postcss/postcss.png)](https://travis-ci.org/postcss/postcss)\n\n<img align=\"right\" width=\"95\" height=\"95\" src=\"http://postcss.github.io/postcss/logo.png\" title=\"Philosopher's stone, logo of PostCSS\">\n\nPostCSS is a framework for CSS postprocessors,\nto modify CSS with JavaScript with full source map support.\n\nIt takes care of most common CSS tool tasks:\n\n1. parses CSS;\n2. gives you usable JS API to edit CSS node tree;\n3. dumps modified node tree into CSS string;\n4. generates (or modifies existent) source map for your changes;\n\nYou can use this framework to write you own:\n\n* CSS minifier or beautifier.\n* CSS polyfills.\n* Grunt plugin to generate sprites, include `data-uri` images\n  or any other works.\n* Text editor plugin to automate CSS routine.\n* Command-line CSS tool.\n\nSponsored by [Evil Martians](http://evilmartians.com/).\n\n## Built with PostCSS\n\n### Tools\n\n* [Autoprefixer] adds vendor prefixes by Can I Use data.\n* [css2modernizr] analyzes your CSS and output only used Modernizr’s settings.\n* [CSS MQPacker] joins same media queries.\n* [CSSWring] and [grunt-csswring] CSS minifier with full source map support.\n* [data-separator] splits data-uri into a separate CSS file.\n* [grunt-pixrem], `rem` unit polyfill.\n* [grunt-webpcss] to duplicate images in CSS to WebP for supported browsers.\n* [Pleeease] is a pack of various postprocessors.\n* [Pleeease Filters] converts WebKit filters to SVG filter for other browsers.\n* [RTLCSS] mirrors styles for right-to-left locales.\n\n\n[Autoprefixer]:     https://github.com/postcss/autoprefixer\n[css2modernizr]:    https://github.com/vovanbo/css2modernizr\n[CSS MQPacker]:     https://github.com/hail2u/node-css-mqpacker\n[CSSWring]:         https://github.com/hail2u/node-csswring\n[data-separator]:   https://github.com/Sebastian-Fitzner/grunt-data-separator\n[grunt-csswring]:   https://github.com/princed/grunt-csswring\n[grunt-pixrem]:     https://github.com/robwierzbowski/grunt-pixrem\n[grunt-webpcss]:    https://github.com/lexich/grunt-webpcss\n[Pleeease]:         http://pleeease.io/\n[Pleeease Filters]: https://github.com/iamvdo/pleeease-filters\n[RTLCSS]:           https://github.com/MohammadYounes/rtlcss\n\n### Plugins\n\n* [postcss-calc] to reduce `calc()` usage\n  (recommanded with `postcss-custom-properties`).\n* [postcss-color] to transform latest W3C CSS color module syntax\n  to more compatible CSS.\n* [postcss-import] to transform @import rules by inlining content.\n* [postcss-custom-media] to transform W3C CSS Custom Media Queries\n  to more compatible CSS.\n* [postcss-custom-properties] to transform W3C CSS Custom Properties\n  for cascading variables to more compatible CSS.\n\n[postcss-calc]:              https://github.com/postcss/postcss-calc\n[postcss-color]:             https://github.com/postcss/postcss-color\n[postcss-import]:            https://github.com/postcss/postcss-import\n[postcss-custom-media]:      https://github.com/postcss/postcss-custom-media\n[postcss-custom-properties]: https://github.com/postcss/postcss-custom-properties\n\n\n## Quick Example\n\nLet’s fix forgotten `content` property in `::before` and `::after`:\n\n```js\nvar postcss = require('postcss');\n\nvar contenter = postcss(function (css) {\n    css.eachRule(function (rule) {\n        if ( rule.selector.match(/::(before|after)/) ) {\n            // In every ::before/::after rule\n\n            // Did we forget content property?\n            var good = rule.some(function (i) { return i.prop == 'content'; });\n\n            if ( !good ) {\n                // Add content: \"\" if we forget it\n                rule.prepend({ prop: 'content', value: '\"\"' });\n            }\n\n        }\n    });\n});\n```\n\nAnd then CSS with forgotten `content`:\n\n```css\na::before {\n    width: 10px;\n    height: 10px\n}\n```\n\nwill be fixed by our new `contenter`:\n\n```js\nvar fixed = contenter.process(css).css;\n```\n\nto:\n\n```css\na::before {\n    content: \"\";\n    width: 10px;\n    height: 10px\n}\n```\n\n## Features\n\n### Source Map\n\nPostCSS generates source map for its changes:\n\n```js\nresult = processor.process(css, { map: true, from: 'from.css', to: 'to.css' });\nresult.css // String with processed CSS\nresult.map // Source map\n```\n\nAnd modifies source map from previous step (like Sass preprocessor):\n\n```js\nvar sass = compiler.compile(sass);\n\nprocessor.process(sass.css, {\n    map:  { prev: sass.map },\n    from: 'from.sass.css',\n    to:   'to.css'\n});\n```\n\n### Preserves code formatting and indentations\n\nPostCSS will not change any byte of a rule if you don’t modify its node:\n\n```js\npostcss(function (css) { }).process(css).css == css;\n```\n\nAnd when you modify CSS nodes, PostCSS will try to copy coding style:\n\n```js\ncontenter.process(\"a::before{color:black}\")\n// a::before{content:'';color:black}\n\ncontenter.process(\"a::before {\\n  color: black;\\n  }\")\n// a::before {\n//   content: '';\n//   color: black;\n//   }\n```\n\nIt allows to use PostCSS in text editor plugin and preserve user code style.\n\n## Why PostCSS Better Than …\n\n### Preprocessors\n\nPreprocessors (like Sass or Stylus) give us special language with variables,\nmixins, statements and compile it to CSS. Compass, nib and other mixins\nlibraries use these languages to work with prefixes, sprites and inline images.\n\nBut Sass and Stylus languages were created to be syntax-sugar for CSS.\nWriting really complicated programs using preporcessor languages\nis very difficult. [Autoprefixer] is absolutely impossible to implement\non top of Sass.\n\nPostCSS gives you comfort and power of JS or CoffeeScript to working with CSS.\nYou can do really magic things with wide range of [npm] libraries.\n\nBut postprocessors are not enemies for preprocessors. Sass and Stylus are still\nthe best way to improve readability and add some syntax sugar to CSS.\nYou can easily combine preprocessors and postprocessors\n(and PostCSS will also update source map from Sass or Stylus).\n\n[Autoprefixer]: https://github.com/postcss/autoprefixer\n[npm]:          https://npmjs.org/\n\n### RegExp\n\nSome Grunt plugins modify CSS with regular expressions but using a CSS parser\nand a node tree is a much safer way to edit CSS. Also, regexps will break\nsource maps generated by preprocessors.\n\n### CSS Parsers\n\nThere are a lot of good CSS parsers, like [Gonzales]. But they help you only\nwith first step.\n\nUnlike them PostCSS gives you full source map support and useful high level API\n(for example, safe iterators).\n\n[Gonzales]: https://github.com/css/gonzales\n\n### Rework\n\n[Rework] and PostCSS are very similar, but they has different targets.\n\nRework was created to build new CSS sublanguage to replace Stylus (like [Myth]).\nPostCSS was created for CSS tools, which works in chain with legacy CSS code\n(like Autoprefixer).\n\nBecause of this background difference, PostCSS:\n\n* Better works with source map, because it should update map from previous step\n  (like Sass compiling).\n* Saves all your spaces and code style, because it can be worked in text editor\n  plugins.\n* Has safer parser, because it can be used for legacy code. Only PostCSS can\n  parse all hacks from [Browserhacks.com](http://browserhacks.com/).\n* Has high level API to clean your processor from common tasks.\n\n[Myth]:   http://www.myth.io/\n[Rework]: https://github.com/visionmedia/rework\n\n## Usage\n\n### Gulp\n\nThere is a gulp plugin for postcss called\n[gulp-postcss](https://github.com/w0rm/gulp-postcss)\nthat allows to pipe your CSS files through array of PostCSS processors.\n\nExternal source map is supported\nby [gulp-sourcemaps](https://github.com/floridoo/gulp-sourcemaps).\n\n```js\nvar gulp       = require('gulp');\nvar postcss    = require('gulp-postcss');\nvar sourcemaps = require('gulp-sourcemaps');\n\ngulp.task('css', function () {\n    var processors = [\n        require('autoprefixer')('last 1 version').postcss,\n        require('css-mqpacker').processor,\n        require('csswring').postcss\n     ];\n     return gulp.src('./src/style.css')\n        .pipe(sourcemaps.init())\n        .pipe(postcss(processors))\n        .pipe(sourcemaps.write('.'))\n        .pipe(gulp.dest('./dest'));\n});\n```\n\n## Write Own Processor\n\nYou can parse CSS by `postcss.parse()` method, which returns CSS AST:\n\n```js\nvar postcss = require('postcss');\n\nvar css = postcss.parse('a { color: black }');\n```\n\nThen you can change this AST. Use `css.list` to get childs.\nProperties `rule.selector`, `decl.prop`, `decl.value`, `atrule.name`\nand `atrule.params` contain data.\n\nDon’t use underscore properties (like `_selector`, `_params` and `_value`),\nbecause they are only for comments save magic\n(See [Raw Properties](#raw-properties) below). Use getters and setters instead\n(like `selector`, `selectors`, `params` and `value`).\n\n```js\ncss.list[0].value = 'white';\n```\n\nAfter changes you can get new CSS and modification’s source map:\n\n```js\nvar result = css.toResult(options);\n\nresult.css //=> 'a { color: white }'\nresult.map //=> '{\"version\":3, … }'\n```\n\nMethods `postcss.parse()` and `CSS#toResult()` are low level API, for most cases\nit will be better to create processors with simplier API and chaining.\n\n### Processor\n\nThe function `postcss(fn)` creates a processor from your function:\n\n```js\nvar postcss = require('postcss');\n\nvar processor = postcss(function (css, opts) {\n    // Code to modify CSS\n});\n```\n\nIf you want to combine multiple processors (and parse CSS only once),\nyou can add several functions using the `use(fn)` method:\n\n```js\nvar all = postcss().\n          use(prefixer).\n          use(minifing);\n```\n\nProcessor function can change the current CSS node tree:\n\n```js\npostcss(function (css) {\n    css.append( /* new rule */ )\n});\n```\n\nor create a completely new CSS root node and return it instead:\n\n```js\npostcss(function (css) {\n    var newCSS = postcss.root()\n    // Add rules and declarations\n    return newCSS;\n});\n```\n\nThis generated processor transforms some CSS using `process(css, opts)` method:\n\n```js\nvar doubler = postcss(function (css) {\n    // Clone each declaration\n    css.eachDecl(function (decl) {\n        decl.parent.prepend( decl.clone() );\n    });\n});\n\nvar css    = \"a { color: black; }\";\nvar result = doubler.process(css);\n\nresult.css //=> \"a { color: black; color: black; }\"\n```\n\nYou can set the original CSS filename via `from` option and make syntax error\nmessages much more helpful:\n\n```js\nvar wrong = \"a {\";\nprocessor.process(wrong, { from: 'main.css' });\n//=> Can't parse CSS: Unclosed block at line 1:1 in main.css\n```\n\nOptions from `process(css, opts)` will be sent to processors\nas seconds argument.\n\nYou can also use result from previous postprocessor or already parsed `Root`\nas argument in next one:\n\n```js\nresult = processor1.process(css)\nprocessor2.process(result)\n```\n\n### Multiple Inputs\n\nThe function `postcss()` generates processor only for one input.\nIf you need to process several inputs (like in files concatenation) you can use\n`postcss.parse()`.\n\nLet’s join two CSS with source map support in 5 lines of code:\n\n```js\nvar file1 = postcss.parse(css1, { from: 'a.css' });\nvar file2 = postcss.parse(css2, { from: 'b.css' });\n\nfile1.append( file2 );\n\nvar result = file1.toResult({ to: 'app.css', map: true });\n```\n\n### Source Map\n\nWith [source maps], browser’s development tools will show you origin position\nof your styles. For example, inspector will show position in Sass file,\neven if you compile it to CSS, concatenate and minify it.\n\nTo generate correct source map every CSS processing step should update map from\nprevious step. Sass compiler should generate first map, concatenation tool\nshould update map from Sass step and minifier should update map from concat.\n\nThere is 2 way to store map:\n\n* You can put it to separated file and add special annotation comment\n  with map path to CSS:\n\n  ```css\n a { }\n /*# sourceMappingURL=main.out.css.map */\n  ```\n* Or you can inline map to CSS annotation comment by base64:\n\n  ```css\n a { }\n /*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5taW4uY3NzIiwic291cmNlcyI6WyJtYWluLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFLIn0= */\n  ```\n\nPostCSS has great source map support. You must set input and output CSS files\npaths (using `from` and `to` options respectively) to generate correct source\nmap.\n\nTo generate new source map with default options just set `map: true` option in\n`processor.process(css, opts)`.\n\n```js\nvar result = processor.process(css, {\n    from: 'main.css',\n    to:   'main.out.css'\n    map:  true,\n});\n\nresult.map //=> '{\"version\":3,\"file\":\"main.out.css\",\"sources\":[\"main.css\"],\"names\":[],\"mappings\":\"AAAA,KAAI\"}'\n\nfs.writeFileSync('main.out.css',     result.css);\nfs.writeFileSync('main.out.css.map', result.map);\n```\n\nOr set `from` in `postcss.parse(css, opts)` and `to` in `root.toResult(opts)`:\n\n```js\nvar root = postcss.parse(css, { from: 'main.css' });\nroot.last.removeSelf();\n\nvar result = root.toResult({ to: 'main.out.css' });\nfs.writeFileSync('main.out.css',     result.css);\nfs.writeFileSync('main.out.css.map', result.map);\n```\n\nIf PostCSS will find source map in previous CSS, it will automatically update\nit with same options.\n\n```js\n// main.sass.css has annotation comment with link to main.sass.css.map\nvar result = minifier.process(css, { from: 'main.sass.css', to: 'main.min.css' });\nresult.map //=> Source map from main.sass to main.min.css\n```\n\nIf you want to control map generation you can set object with parameters\nto `map` option:\n\n* `inline` (boolean): should we inline map to CSS annotation comment.\n  By default, PostCSS will inline new maps only if map was inlined\n  in previous CSS.\n\n  If you inline map, `result.map` will be empty, because map will be\n  in `result.css` text.\n\n  You can shortcut `map { inline: true }` to `map: 'inline'`.\n\n* `prev` (strong or object): map content from previous processing step\n  (like Sass compilation). PostCSS will try to read previous map automatically\n  by annotation comment in origin CSS, but you can set it manually. Also you can\n  remove previous map by `prev: false`.\n\n  This option is only one map option, which can be passed\n  to `postcss.parse(css, opts)`. Other options is for `toResult(opts)`\n  or `process(css, opts)` method.\n\n* `sourcesContent` (boolean): should we set origin content (for example,\n  Sass source) to map. By default, PostCSS will add content only if previous map\n  contains it.\n\n* `annotation` (boolean or string): should we add annotation comment to CSS.\n  By default, PostCSS always adds annotation with path to map. But if all\n  previous CSS have not annotation, PostCSS will miss it too.\n\n  By default, PostCSS thinks, that you will save map to `opts.to + '.map'`,\n  and uses this path in annotation. But you can set another path as string value\n  in `annotation` option.\n\n  If you set `inline: true`, of cource, you will not be able disable annotation.\n\n[source maps]: http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/\n\n### Safe Mode\n\nIf you will set `safe: true` option to `process` or `parse` methods,\nPostCSS will try to fix any syntax error, that it founds in CSS.\nFor example, it will parse `a {` as `a {}`.\n\n```js\npostcss.parse('a {');                 // will throw \"Unclosed block\"\npostcss.parse('a {', { safe: true }); // will return CSS root for a {}\n```\n\nIt is useful for legacy code with a lot of hack. Other use case is a interactive\ntools with live input, like\n[Autoprefixer demo](http://jsfiddle.net/simevidas/udyTs/show/light/).\n\n### Helpers\n\n#### Vendor\n\nPostCSS contains heigh optimized code to split vendor prefix:\n\n```js\nvar vendor = require('postcss/lib/vendor');\n\nvendor.prefix('-moz-tab-size')     //=> '-moz-'\nvendor.unprefixed('-moz-tab-size') //=> 'tab-size'\n```\n\n#### List\n\nTo safely split comma- or space-separated values (like in `background-image`\nor `transform` ) with brackets and quotes support you can use `list` helper:\n\n```js\nvar list = require('postcss/lib/list');\n\nlist.space(image.value)     //=> ['linear-gradient(white, black)', 'blue']\nlist.comma(transform.value) //=> ['color 200ms', 'background 200ms']\n```\n\n### Nodes\n\nProcessor function receives `Root` node with CSS node tree inside.\n\n```js\nvar processor = postcss(function (cssRoot) {\n});\n```\n\nThere are 4 types of child nodes: `Comment`, `AtRule`, `Rule` and `Declaration`.\nAll nodes have `toString()` and `clone()` methods.\n\nYou can parse CSS and get a `Root` node by `postcss.parse(css, opts)` method:\n\n```js\nvar cssRoot = postcss.parse('a { }');\n```\n\nAll node‘s methods return current node, so you can build nice method chains:\n\n```js\nroot.append( rule1 ).append( rule2 ).toString();\n```\n\n### Node Source\n\nEvery node stores its origin file (if you set `from` option to `process`\nor `parse` method) and position:\n\n```js\nvar root = postcss.parse(css, { from: 'main.css' });\nvar rule = root.rules[0];\n\nrule.source.file  //=> 'main.css'\nrule.source.start //=> { line: 5,  position: 1 }\nrule.source.end   //=> { line: 10, position: 5 }\n```\n\n### Whitespaces\n\nAll nodes (exclude `Root`) have `before` property with indentation\nand all earlier spaces.\n\nNodes with children (`Root`, `AtRule` and `Rule`) contain also `after` property\nwith spaces after last child and before `}` or end of file.\n\nEvery `Declaration` has `between` property with colon, spaces and comments\nbetween property name and value. `Rule` stores spaces and comments between\nselector and `{` in `between` property. `AtRule` uses `between` also to store\nspaces and comments before `{` or `;` for bodiless at-rule.\n\n```js\nvar root = postcss.parse(\"a {\\n  color: black;\\n}\\n\");\n\nroot.rules[0].between          //=> \" \" between selector and {\nroot.rules[0].decls[0].before  //=> \"\\n  \" before color: black\nroot.rules[0].decls[0].between //=> \": \" between property name and value\nroot.rules[0].after            //=> \"\\n\" before }\nroot.after                     //=> \"\\n\" from end of file\n```\n\nThe simplest way to minify CSS is to set `before`, `between` and `after`\nproperties to an empty string:\n\n```js\nvar minifier = postcss(function (css) {\n    css.eachDecl(function (decl) {\n        decl.before  = '';\n        decl.between = ':';\n    });\n    css.eachRule(function (rule) {\n        rule.before  = '';\n        rule.between = '';\n        rule.after   = '';\n    });\n    css.eachAtRule(function (atRule) {\n        atRule.before  = '';\n        atRule.between = '';\n        atRule.after   = '';\n    });\n    css.eachComment(function (comment) {\n        comment.removeSelf();\n    });\n});\n\nvar css = \"a {\\n  color:black\\n}\\n\";\nminifier.process(css).css //=> \"a{color:black}\"\n```\n\n### Raw Properties\n\nSome CSS values (selectors, comment text, at-rule params and declaration values)\ncan contain comments. PostCSS will clean them from trailing spaces for you:\n\n```js\nvar root = postcss.parse(\"a /**/ b {}\");\nvar rule  = root.rules[0];\n\nrule.selector      //=> 'a  b' trimmed and cleaned from comments\nrule._selector.raw //=> 'a /**/ b' original raw value\n```\n\nBut PostCSS saves raw content to be able to stringify it to CSS, if you don’t\nchange origin value. As you can remember, PostCSS tries to save origin CSS\nbyte-to-byte, when it’s possible:\n\n```js\nrule.toString() //=> 'a /**/ b {}' with comment\n\nrule.selector = '.link b';\nrule.toString() //=> '.link b {}' you change value and origin comment was gone\n```\n\n### Containers\n\n`Root`, `AtRule` and `Rule` nodes can contain children in `rules` or `decls`\nproperty.\n\nThere are common method to work with children:\n\n* `append(newChild)` to add child at the end of children list.\n* `prepend(newChild)` to add child at the beginning of children list.\n* `insertBefore(existsChild, newChild)` to insert new child before some\n   existent child.\n* `insertAfter(existsChild, newChild)` to insert new child after some\n   existent child.\n* `remove(existsChild)` to remove child.\n* `index(existsChild)` to return child index.\n* `some(fn)` to return true if `fn` returns true on any child.\n* `every(fn)` to return true if `fn` returns true on all children.\n\nMethods `append`, `prepend`, `insertBefore` and `insertAfter` can receive\narrays and `Root` as new child argument.\n\nMethods `insertBefore`, `insertAfter` and `remove` can receive child node\nor child index as an `existsChild` argument. Have in mind that child index works\nmuch faster.\n\nThere are two shorcuts to get first and last child:\n\n```js\nrule.first //=> First declaration in rule\nrule.last  //=> Last declaration in rule\n```\n\n### Children\n\n`Comment`, `AtRule`, `Rule` and `Declaration` nodes should be wrapped\nin other nodes.\n\nAll children contain `parent` property with parent node:\n\n```js\nrule.decls[0].parent == rule;\n```\n\nAll children has `removeSelf()` method:\n\n```js\nrule.decls[0].removeSelf();\n```\n\nBut `remove(index)` in parent with child index is much faster:\n\n```js\nrule.each(function (decl, i) {\n    rule.remove(i);\n});\n```\n\n### Iterators\n\nAll parent nodes have `each` method to iterate over children nodes:\n\n```js\nroot = postcss.parse('a { color: black; display: none }');\n\nroot.each(function (rule, i) {\n    if ( rule.type == 'rule' ) {\n        console.log(rule.selector, i); // Will log \"a 0\"\n    }\n});\n\nroot.rules[0].each(function (decl, i) {\n    if ( rule.type != 'comment' ) {\n        console.log(decl.prop, i); // Will log \"color 0\" and \"display 1\"\n    }\n});\n```\n\nUnlike `for {}`-cycle construct or `Array#forEach()` this iterator is safe.\nYou can mutate children while iteration and it will fix current index:\n\n```js\nrule.rules.forEach(function (decl, i) {\n    rule.prepend( decl.clone() );\n    // Will be infinity cycle, because on prepend current declaration become\n    // second and next index will go to current declaration again\n});\n\nrule.each(function (decl, i) {\n    rule.prepend( decl.clone() );\n    // Will work correct (once clone each declaration), because after prepend\n    // iterator index will be recalculated\n});\n```\n\nBecause CSS have nested structure, PostCSS also contains recursive iterator\n`eachInside`:\n\n```js\nroot.eachInside(function (node, i) {\n    console.log(node.type + ' inside ' + node.parent.type);\n});\n```\n\nThere are also shortcuts to recursive iterate all nodes of specific type:\n\n```js\nroot.eachDecl(function (decl, i) {\n    // Each declaration inside root\n});\n\nroot.eachRule(function (rule, i) {\n    // Each rule inside root and any nested at-rules\n});\n\nroot.eachAtRule(function (atRule, i) {\n    // Each at-rule inside root and any nested at-rules\n});\n\nroot.eachComment(function (comment, i) {\n    // Each comment inside root\n})\n```\n\nYou can break iteration by `return false`.\n\n### Root Node\n\n`Root` node contains entire CSS tree. Its children can be only `Comment`,\n`AtRule` or `Rule` nodes in `rules` property.\n\nYou can create a new root using shortcut:\n\n```js\nvar root = postcss.root();\n```\n\nMethod `toString()` stringifies entire node tree to CSS string:\n\n```js\nroot = postcss.parse(css);\nroot.toString() == css;\n```\n\nIf PostCSS found previous source map, it will save all information\nin `Root#prevMap`:\n\n```\nroot = postcss.parse(css);\nif (root.prevMap && root.prevMap.inline) {\n    console.log('Inlined map: ' + root.prevMap.annotation)\n}\n```\n\n### Comment Node\n\n```css\n/* Block comment */\n```\n\nPostCSS creates `Comment` nodes only for comments between rules or declarations.\nComments inside selectors, at-rules params, declaration values will be stored\nin Raw property.\n\n`Comment` has only one property: `text` with trimmed text inside comment.\n\n```js\ncomment.text //=> \"Block comment\"\n```\n\nYou can create a new comment using shortcut:\n\n```js\nvar comment = postcss.comment({ text: 'New comment' });\n```\n\n### AtRule Node\n\n```css\n@charset 'utf-8';\n\n@font-face {\n    font-family: 'Cool'\n}\n\n@media print {\n    img { display: none }\n}\n```\n\n`AtRule` has two own properties: `name` and `params`.\n\nAs you see, some at-rules don’t contain any children (like `@charset`\nor `@import`), some of at-rules can contain only declarations\n(like `@font-face` or `@page`), but most of them can contain rules\nand nested at-rules (like `@media`, `@keyframes` and others).\n\nParser selects `AtRule` content type by its name. If you create `AtRule`\nnode manually, it will detect own content type with new child type on first\n`append` or other add method call:\n\n```js\nvar atRule = postcss.atRule({ name: '-x-animations' });\natRule.rules        //=> undefined\natRule.decls        //=> undefined\n\natRule.append( postcss.rule({ selector: 'from' }) );\natRule.rules.length //=> 1\natRule.decls        //=> undefined\n```\n\nYou can create a new at-rule using shortcut:\n\n```js\nvar atRule = postcss.atRule({ name: 'charset', params: 'utf-8' });\n```\n\n### Rule Node\n\n```css\na {\n    color: black;\n}\n```\n\n`Rule` node has `selector` property and contains `Declaration` and `Comment`\nchildren in `decls` property.\n\nThere is `selectors` shortcut, which return array:\n\n```js\nrule.selector  //=> \"a, b\"\nrule.selectors //=> ['a', 'b']\n```\n\nYou can miss `Declaration` constructor in `append` and other insert methods:\n\n```js\nrule.append({ prop: 'color', value: 'black' });\n```\n\nProperty `semicolon` indicates if last declaration in rule has semicolon or not:\n\n```js\nvar root = postcss.parse('a { color: black }');\nroot.rules[0].semicolon //=> false\n\nvar root = postcss.parse('a { color: black; }');\nroot.rules[0].semicolon //=> true\n```\n\nYou can create a new rule using shortcut:\n\n```js\nvar rule = postcss.rule({ selector: 'a' });\n```\n\n### Declaration Node\n\n```css\ncolor: black\n```\n\n`Declaration` node has `prop`, `value` and `important` properties.\n\nYou can create a new declaration using this shortcut:\n\n```js\nvar decl = postcss.decl({ prop: 'color', value: 'black' });\n```\n\nOr use short form in rule’s `append()` and other add methods:\n\n```js\nrule.append({ prop: 'color', value: 'black' });\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/postcss/postcss/issues"
  },
  "homepage": "https://github.com/postcss/postcss",
  "_id": "postcss@2.2.1",
  "_shasum": "9141516f74f3b7a7ece22de18f6937e03a38e894",
  "_from": "postcss@~2.2.1",
  "_resolved": "https://registry.npmjs.org/postcss/-/postcss-2.2.1.tgz"
}
